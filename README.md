# EECS-338
Programming exercises from EECS 338 Introduction to Operating Systems and Concurrent Programming

Instructions for hw2q3.c:
Write a c program that takes the output of a “top -b -n 1” command and prints the lines that correspond to processes belonging to root. And only those lines. You can generate sample input by saying  “top -b -n 1 > top.snapshot.3.c” at the command shell (if for some reason you can’t get that command to work, e.g., on a mac, I put 10 snapshots here, e.g., http://codereserve.us/338/top.snapshot.9). Here is a quick guide to the output of the top command if you care https://tecadmin.net/understanding-linux-top-command-results-uses/ . You will have to choose a way to read the input, but I recommend fscanf. Look at examples online such at this: https://www.tutorialspoint.com/c_standard_library/c_function_fscanf.htm .

Instructions for hw2q4.c: 
Modify the last program (from hw2q3) so it sums each memory amount, %, and time elapsed amount, reporting just the sum for root’s processes. Yes, you have to figure out how to sum minutes and seconds. If you don’t take care of days, or convert minutes into hours, I won’t mind. In fact, you could report the time in total minutes if you want. 

Instructions for hw2q5.c: 
Take two snapshots using top. (Do “top -b -n > top.snapshot.3.c” and “top -b -n > top.snapshot.4.c”.) Modify your program so it reports only the differences for each pid (process id), either because a process is new, an old process is no longer being shown, or because the cpu time or memory use has changed. I don’t care about the other columns. You can do memory-change in terms of % and ignore the other three memory columns. What I recommend here is that you allocate an array float pmem[32768] and an array float pcpu[32768] and initialize values to 0 with a loop. Then read one file, parse, and assign values. Then read the other file, parse, and report differences. 

Instructions for HW_5_6.ipynb: 
The problem is simple.  We will investigate Peterson's Algorithm with simulation.  This means you have to write a program, but I don't care what programming language you use.  If you absolutely can't write a program to do this, I will accept some manual simulations.
1.  Consider each step in the entry and exit sections.  There is an assignment of intention to enter, P1.  There is an assignment of whose turn it is, P2.  There is a spin wait with two non-atomic tests (test for other process intention P3a, and for other process turn, P3b.  Then there is the critical section, P4.  Then there is the exit relinquishing of the intention, P5.  This numbering may be different from Silberschatz's slides.  Consider the corresponding steps in the other process Q1, ... Q5.  Choose a random interleaving of Ps and Qs.  P1, ..., P5 and Q1, ..., Q5 must be ordered within each P sequence and Q sequence, but the ordering of P's relative to Q's can be any possible, e.g. P1, P2, Q1, P3a, Q2, Q3a, Q3b, ... .  Also, P4, P5 and Q4, Q5 are constrained to occur only if the conditions for P3a,b and Q3a,b obtain.  Show that for your random ordering that there is mutual exclusion, i.e., P4 and Q4 are not adjacent.
2.  Use your program to generate more random interleavings.  Remember that P3a or P3b must be false in order to proceed to P4.  Similarly, for Q3a, Q3b, and Q4.  Or if you are doing this manually, do two more scenarios randomly.  To receive full credit, show your program and the output for each scenario.
3.  How many well-formed interleavings are possible?  How can we know this?
